
import os
import psycopg2
import psycopg2.extras
import tabulate
from dotenv import load_dotenv

# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor)
    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    
    _global = []
    
    
    from collections import defaultdict
    import re

    cols = [desc[0] for desc in cur.description]
    relation = [dict(zip(cols, row)) for row in cur.fetchall()]

    select = "cust, sum_quant, avg_quant"
    groupingAttributes = "cust"
    predicate = "state == 'NY',state == 'NY',avg_quant > 30".strip()
    havingVar = "avg_quant > 30".strip()

    select_fields = [s.strip() for s in select.split(',') if s.strip()]
    grouping_attributes = [g.strip() for g in groupingAttributes.split(',') if g.strip()]


    if predicate:
        predicate_expr = ' and '.join(predicate.split(','))
        filtered = []
        for t in relation:
            try:
                if eval(predicate_expr, {}, t):
                    filtered.append(t)
            except:
                continue
    else:
        filtered = relation


    grouped = defaultdict(list)
    for t in filtered:
        key = tuple(t[attr] for attr in grouping_attributes)
        grouped[key].append(t)

    result = []
    for group_key, tuples in grouped.items():
        aggregates = defaultdict(lambda: 0)
        count_tracker = defaultdict(int)
        row = {grouping_attributes[i]: val for i, val in enumerate(group_key)}

        for t in tuples:
            for field in select_fields:
                match = re.match(r"(sum|avg|min|max|count)_(\w+)", field)
                if not match:
                    continue
                prefix, func, attr = match.groups()
                key = f"{prefix or ''}{func}_{attr}"

                try:
                    if func == 'sum':
                        aggregates[key] += t[attr]
                    elif func == 'count':
                        aggregates[key] += 1
                    elif func == 'avg':
                        aggregates[key] += t[attr]
                        count_tracker[key] += 1
                    elif func == 'min':
                        aggregates[key] = min(t[attr], aggregates[key]) if key in aggregates else t[attr]
                    elif func == 'max':
                        aggregates[key] = max(t[attr], aggregates[key]) if key in aggregates else t[attr]
                
                except:
                    continue

        for k, v in aggregates.items():
            if k.startswith('avg_') or "_avg_" in k:
                row[k] = v / count_tracker[k] if count_tracker[k] > 0 else 0
            else:
                row[k] = v
        
        try:
            if not havingVar or eval(havingVar, {}, row):
                result.append(row)
        except:
            continue

                
    for r in result:
        print(', '.join(str(r.get(f.strip(), '')) for f in select_fields))
    
    
    
    #return tabulate.tabulate(_global,
                        #headers="keys", tablefmt="psql")

def main():
    print(query())
    
if "__main__" == __name__:
    main()
    